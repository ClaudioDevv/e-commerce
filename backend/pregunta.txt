1. En cuanto al tema errores es algo que no llevo entendiendo bien hace mucho, nosotros tenemos un error personalizado llamado AppError y luego tenemos un globalhandler de errores, necesito que me expliques porque se hace esto, explicame el código de ambos y el flujo que sigue un error de la aplicación, el uso de next(error) siempre en los catch, etc.
Significa que siempre que falla un try y pasa al catch es siempre error del servidor?
2. Como cuando hicimos la api de productos e ingredientes no teniamos el appError intentando entener los errores he cambiado el código para que se ajuste a los errores como lo hacemos ahora, te lo enseño:
ingredientsController.ts
export const getIngredients = async (req: Request, res: Response, next: NextFunction) => {
try {
const ingredients = await ingredientModel.getAllIngredients()
res.status(200).json({
success: true,
data: ingredients
 })
 } catch (error: any) {
next(error)
 }
}

productController.ts
export const getAllProducts = async (req: Request, res: Response, next: NextFunction) => {
 try {
const products = await productModel.getAll()
res.status(200).json({
success: true,
data: products
 })
 } catch (error) {
next(error)
 }
}
export const getProductsByCategory = async (req: Request, res: Response, next: NextFunction) => {
try {
const { category: catParam } = req.params
const upperCat = catParam.toUpperCase()
// Validación: comprobar que la string recibida es un valor del enum
const validValues = Object.values(Category) as string[]
if (!validValues.includes(upperCat)) {
throw new AppError('Categoría no existente', 404)
 }
const category = upperCat as Category
const products = await productModel.getByCategory(category)
res.status(200).json({
success: true,
data: products
 })
 } catch (error) {
next(error)
 }
}

3. Pregunta a parte, par hacer el carrito luego no vamos a tener que recuperar producto por id? lo digo porque no lo tenemos implementado para saber.